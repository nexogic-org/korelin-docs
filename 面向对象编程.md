# 面向对象编程 (Object-Oriented Programming)

## 概述
Korelin 支持面向对象编程范式，允许通过类（Class）来封装数据和行为。

## 类的定义

使用 `class` 关键字定义类。类中可以包含成员变量（属性）和成员函数（方法）。

### 语法
```korelin
class ClassName {
    // 成员变量 (作用域都是在类内)
    // 语法: 访问修饰符 var [const] [Type] 变量名 [= 初始值];
    public var name;                 // 动态类型推断
    private var int age = 0;         // 显式类型声明
    public var const PI = 3.14159;   // 常量成员

    // 构造函数 (第一个参数必须是 self)
    // 必须声明返回类型（通常为 void）
    // 支持 _init 或 _init_ 作为构造函数名
    // 注意：成员变量的初始化会在构造函数体执行之前自动完成
    public void _init(self, 参数列表) {
        // 初始化代码
    }

    // 成员方法 (第一个参数必须是 self)
    public void 方法名(self, 参数列表) {
        // 方法体
    }

    // 静态方法 (不包含 self 参数)
    public static void 静态方法名(参数列表) {
        // 方法体
    }
}
```

## 继承 (Inheritance)

使用 `extends` 关键字实现继承。子类可以继承父类的属性和方法。

### 语法
```korelin
class ChildClass extends ParentClass {
    public void _init(self, args) {
        super(args); // 激活父类构造函数
    }
}
```

## 访问修饰符 (Access Modifiers)

Korelin 提供以下访问修饰符来控制成员的可见性：

*   `public`: 公开，任何地方都可以访问。
*   `private`: 私有，仅在类内部可以访问。
*   `protected`: 受保护，仅在类内部及其子类中可以访问。

## self 对象

在类的实例方法中，必须将 `self` 作为第一个参数传入，以便访问当前对象的属性和方法。

```korelin
class Person {
    public var string name;
    public var int age;

    // 构造函数
    public void _init(self, string n, int a) {
        self.name = n;
        self.age = a;
    }

    // 实例方法
    public void sayHello(self) {
        print("Hello, my name is " + self.name);
    }
}
```

## 构造函数 (Constructor)

类的构造函数命名为 `_init` 或 `_init_`。第一个参数必须是 `self`。当使用 `new` 关键字创建类的新实例时，会自动调用该方法并隐式传递新创建的对象给 `self`。

**自动初始化**：如果在声明成员变量时提供了初始值（例如 `public var int age = 10;`），这些赋值操作会在 `_init_` 函数体执行**之前**自动完成。如果类中未显式定义 `_init_`，编译器会自动生成一个默认构造函数来处理这些初始化。

在子类构造函数中，必须使用 `super(...)` 调用父类的构造函数（如果父类有构造函数）。

## 对象实例化

使用 `new` 关键字来创建类的实例。对象变量的声明遵循通用的变量作用域规则：

*   `var`: 声明局部变量。
*   `let`: 声明全局变量。
*   `const`: 声明常量引用。

```korelin
// 语法
(var|let) [const] [Type] instanceName = new ClassName(args);
```

### 示例

```korelin
var p1 = new Person("Alice", 30); // 局部对象
let p2 = new Person("Bob", 25);   // 全局对象
```

## 静态成员 (Static Members)

使用 `static` 关键字修饰的方法为静态方法，属于类本身而不是类的实例。静态方法定义时不包含 `self` 参数。

### 调用静态方法
使用 `::` 符号来调用静态方法。支持通过类名或实例名调用。

```korelin
ClassName::staticMethod();
instanceObj::staticMethod();
```

## 完整示例

```korelin
class Animal {
    protected var string name;
    
    public void _init_(self, string n) {
        self.name = n;
    }
    
    public void speak(self) {
        print("Animal speaks");
    }
}

class Dog extends Animal {
    public void _init_(self, string n) {
        super(n); // 调用父类构造函数
    }
    
    public void speak(self) {
        print(self.name + " barks");
    }
    
    public static void info() {
        print("This is a Dog class");
    }
}

// 使用示例
var d = new Dog("Buddy");
d.speak(); // 输出: Buddy barks
Dog::info(); // 输出: This is a Dog class
```

## 类外方法定义 (Out-of-class Method Definition)

Korelin 支持在类定义体外部定义类的方法，语法类似于 C++。这允许将类的声明与实现分离。

### 语法
```korelin
// 类定义
class MyClass {
    public var string name;
    
    // 可以在类内只声明方法签名(暂未强制)，或者直接在外部定义新方法
}

// 类外定义方法
// 语法: [ReturnType] ClassName::MethodName(Parameters) { ... }
// 如果省略 ReturnType，默认为 void

MyClass::myMethod(self) {
    print("Called myMethod on " + self.name);
}

void MyClass::anotherMethod(self, int x) {
    print(x);
}
```
