# 类的继承 (Class Inheritance)

Korelin 支持基于类的单继承机制，允许一个类（子类）继承另一个类（父类）的属性和方法。

## 定义继承

使用 `extends` 关键字来指定父类。

```korelin
class Animal {
    public string name;
    
    public void _init(self, string n) {
        self.name = n;
    }
    
    public void speak(self) {
        os.println(self.name + " makes a noise.");
    }
}

// Dog 继承自 Animal
class Dog extends Animal {
    public void guard(self) {
        os.println(self.name + " is guarding.");
    }
}
```

## 构造函数与 super()

子类的构造函数 (`_init_`) 常常需要调用父类的构造函数来初始化继承的属性。可以使用 `super(...)` 来激活父类构造函数。

```korelin
class Dog extends Animal {
    public string breed;
    
    public void _init(self, string n, string b) {
        // 调用父类构造函数 _init(n)
        super(n); 
        self.breed = b;
    }
}
```

> **注意**：`super(...)` 只能在类的方法内部调用（通常是构造函数），且相当于调用 `super._init_(...)`。

## 方法覆盖与 super.method()

子类可以重新定义（覆盖）父类的方法。如果需要在子类中调用父类原本的实现，可以使用 `super.方法名(...)`。

```korelin
class Cat extends Animal {
    // 覆盖父类的 speak 方法
    public void speak(self) {
        // 先调用父类的实现
        super.speak();
        // 然后执行自己的逻辑
        os.println("And specifically, it meows.");
    }
}
```

## 使用示例

```korelin
void main() {
    var Dog d = new Dog("Rex", "Golden Retriever");
    
    d.speak(); // 输出: Rex makes a noise. (继承自 Animal)
    d.guard(); // 输出: Rex is guarding. (Dog 自己的方法)
    
    var Cat c = new Cat();
    c.name = "Whiskers"; // 如果没有自定义构造函数，需手动赋值或依赖默认构造
    c.speak(); 
    // 输出: 
    // Whiskers makes a noise. (super.speak 调用)
    // And specifically, it meows.
}
```

## 注意事项

1.  **单继承**：一个类只能有一个直接父类。
2.  **方法参数**：非静态类方法的第一个参数必须显式声明为 `self`。
3.  **super 关键字**：
    *   `super(...)`：调用父类构造函数。
    *   `super.method(...)`：调用父类普通方法。
