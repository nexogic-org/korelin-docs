# Nexogic Korelin Bytecode (KRIC) - 完整指令集规范 v2.0

## 核心指令集架构

### 1. 基础指令格式

#### 格式A: RRR (寄存器-寄存器-寄存器)
```
31        24 23        16 15         8 7          0
+------------+------------+------------+-----------+
|   opcode   |     Rd     |     Ra     |     Rb    |
+------------+------------+------------+-----------+
操作码: 8位
目标寄存器: 8位 (Rd)
源寄存器A: 8位 (Ra)
源寄存器B: 8位 (Rb)
```

#### 格式B: RRI (寄存器-寄存器-立即数)
```
31        24 23        16 15         8 7          0
+------------+------------+------------+-----------+
|   opcode   |     Rd     |     Ra     |   imm8    |
+------------+------------+------------+-----------+
立即数: 8位有符号扩展
```

#### 格式C: RI (寄存器-立即数)
```
31        24 23        16 15                      0
+------------+------------+------------------------+
|   opcode   |     Rd     |        imm16           |
+------------+------------+------------------------+
立即数: 16位有符号扩展
```

#### 格式D: I (立即数)
```
31        24 23                                      0
+------------+---------------------------------------+
|   opcode   |                imm24                  |
+------------+---------------------------------------+
立即数: 24位有符号扩展
```

#### 格式E: 系统指令
```
31        24 23                                      0
+------------+---------------------------------------+
|   opcode   |              system_data              |
+------------+---------------------------------------+
系统数据: 24位特殊编码
```

---

## 2. 完整指令集表

### 2.1 算术与逻辑指令 (0x00-0x1F)

#### 整数运算
```
0x00: ADD    Rd, Ra, Rb      ; Rd = Ra + Rb
0x01: SUB    Rd, Ra, Rb      ; Rd = Ra - Rb
0x02: MUL    Rd, Ra, Rb      ; Rd = Ra * Rb
0x03: MULH   Rd, Ra, Rb      ; Rd = (Ra * Rb) >> 64 (高64位)
0x04: DIV    Rd, Ra, Rb      ; Rd = Ra / Rb (有符号)
0x05: UDIV   Rd, Ra, Rb      ; Rd = Ra / Rb (无符号)
0x06: MOD    Rd, Ra, Rb      ; Rd = Ra % Rb (有符号)
0x07: UMOD   Rd, Ra, Rb      ; Rd = Ra % Rb (无符号)
0x08: NEG    Rd, Ra          ; Rd = -Ra
0x09: ABS    Rd, Ra          ; Rd = |Ra|

#### 立即数整数运算
0x10: ADDI   Rd, Ra, imm     ; Rd = Ra + imm
0x11: SUBI   Rd, Ra, imm     ; Rd = Ra - imm
0x12: MULI   Rd, Ra, imm     ; Rd = Ra * imm
0x13: DIVI   Rd, Ra, imm     ; Rd = Ra / imm
0x14: MODI   Rd, Ra, imm     ; Rd = Ra % imm

#### 逻辑运算
0x18: AND    Rd, Ra, Rb      ; Rd = Ra & Rb
0x19: OR     Rd, Ra, Rb      ; Rd = Ra | Rb
0x1A: XOR    Rd, Ra, Rb      ; Rd = Ra ^ Rb
0x1B: NOT    Rd, Ra          ; Rd = ~Ra
0x1C: ANDN   Rd, Ra, Rb      ; Rd = Ra & ~Rb
0x1D: ORN    Rd, Ra, Rb      ; Rd = Ra | ~Rb
0x1E: XORN   Rd, Ra, Rb      ; Rd = Ra ^ ~Rb
0x1F: TEST   Ra, Rb          ; 设置标志位: Ra & Rb
```

#### 移位运算
```
0x20: SHL    Rd, Ra, Rb      ; 逻辑左移
0x21: SHR    Rd, Ra, Rb      ; 逻辑右移
0x22: SAR    Rd, Ra, Rb      ; 算术右移
0x23: ROL    Rd, Ra, Rb      ; 循环左移
0x24: ROR    Rd, Ra, Rb      ; 循环右移
0x25: SHLI   Rd, Ra, imm     ; 立即数左移
0x26: SHRI   Rd, Ra, imm     ; 立即数右移
0x27: SARI   Rd, Ra, imm     ; 立即数算术右移
```

#### 位操作
```
0x28: CLZ    Rd, Ra          ; 前导零计数
0x29: CTZ    Rd, Ra          ; 尾随零计数
0x2A: POPCNT Rd, Ra          ; 人口计数
0x2B: REV    Rd, Ra          ; 位反转
0x2C: BEXT   Rd, Ra, Rb      ; 位提取
0x2D: BDEP   Rd, Ra, Rb      ; 位沉积
0x2E: BGRP   Rd, Ra, Rb      ; 位分组
0x2F: RORI   Rd, Ra, imm     ; 立即数循环右移
```

### 2.2 浮点运算指令 (0x30-0x4F)

#### 单精度浮点
```
0x30: FADD.S Rd, Ra, Rb      ; 单精度加法
0x31: FSUB.S Rd, Ra, Rb      ; 单精度减法
0x32: FMUL.S Rd, Ra, Rb      ; 单精度乘法
0x33: FDIV.S Rd, Ra, Rb      ; 单精度除法
0x34: FMADD.S Rd, Ra, Rb, Rc ; 融合乘加 (Rd = Ra*Rb + Rc)
0x35: FMSUB.S Rd, Ra, Rb, Rc ; 融合乘减 (Rd = Ra*Rb - Rc)
0x36: FNMADD.S Rd, Ra, Rb, Rc; 负融合乘加 (Rd = -(Ra*Rb) + Rc)
0x37: FNMSUB.S Rd, Ra, Rb, Rc; 负融合乘减 (Rd = -(Ra*Rb) - Rc)
```

#### 双精度浮点
```
0x38: FADD.D Rd, Ra, Rb      ; 双精度加法
0x39: FSUB.D Rd, Ra, Rb      ; 双精度减法
0x3A: FMUL.D Rd, Ra, Rb      ; 双精度乘法
0x3B: FDIV.D Rd, Ra, Rb      ; 双精度除法
0x3C: FMADD.D Rd, Ra, Rb, Rc ; 双精度融合乘加
0x3D: FMSUB.D Rd, Ra, Rb, Rc ; 双精度融合乘减
0x3E: FSQRT.D Rd, Ra         ; 双精度平方根
0x3F: FRSQRT.D Rd, Ra        ; 双精度倒数平方根
```

#### 浮点转换与比较
```
0x40: FCVT.S.D Rd, Ra        ; 双精度转单精度
0x41: FCVT.D.S Rd, Ra        ; 单精度转双精度
0x42: FCVT.W.S Rd, Ra        ; 单精度转整数
0x43: FCVT.W.D Rd, Ra        ; 双精度转整数
0x44: FCVT.S.W Rd, Ra        ; 整数转单精度
0x45: FCVT.D.W Rd, Ra        ; 整数转双精度
0x46: FCMP.S Ra, Rb          ; 单精度比较 (设置标志)
0x47: FCMP.D Ra, Rb          ; 双精度比较 (设置标志)
0x48: FEQ.S Rd, Ra, Rb       ; 单精度相等比较
0x49: FLT.S Rd, Ra, Rb       ; 单精度小于比较
0x4A: FLE.S Rd, Ra, Rb       ; 单精度小于等于比较
0x4B: FEQ.D Rd, Ra, Rb       ; 双精度相等比较
0x4C: FLT.D Rd, Ra, Rb       ; 双精度小于比较
0x4D: FLE.D Rd, Ra, Rb       ; 双精度小于等于比较
0x4E: FSGNJ.S Rd, Ra, Rb     ; 单精度符号注入
0x4F: FSGNJ.D Rd, Ra, Rb     ; 双精度符号注入
```

### 2.3 内存访问指令 (0x50-0x6F)

#### 加载指令
```
0x50: LOAD   Rd, [Ra+imm]    ; 加载64位
0x51: LOAD.U Rd, [Ra+imm]    ; 无符号加载64位
0x52: LOAD32 Rd, [Ra+imm]    ; 加载32位，零扩展
0x53: LOAD32S Rd, [Ra+imm]   ; 加载32位，符号扩展
0x54: LOAD16 Rd, [Ra+imm]    ; 加载16位，零扩展
0x55: LOAD16S Rd, [Ra+imm]   ; 加载16位，符号扩展
0x56: LOAD8  Rd, [Ra+imm]    ; 加载8位，零扩展
0x57: LOAD8S Rd, [Ra+imm]    ; 加载8位，符号扩展
```

#### 存储指令
```
0x58: STORE  [Ra+imm], Rb    ; 存储64位
0x59: STORE32 [Ra+imm], Rb   ; 存储32位
0x5A: STORE16 [Ra+imm], Rb   ; 存储16位
0x5B: STORE8  [Ra+imm], Rb   ; 存储8位
```

#### 栈操作
```
0x5C: PUSH   Ra              ; 压栈
0x5D: POP    Rd              ; 弹栈
0x5E: PUSH.R Rlist           ; 寄存器列表压栈
0x5F: POP.R  Rlist           ; 寄存器列表弹栈
0x60: ENTER  imm             ; 进入栈帧
0x61: LEAVE                 ; 离开栈帧
```

#### 地址计算
```
0x62: LEA    Rd, [Ra+imm]    ; 加载有效地址
0x63: LEA.G  Rd, [Ra+Rb]     ; 通用加载有效地址
0x64: LEA.INDEX Rd, [Ra+Rb*scale] ; 索引加载地址
```

#### 原子操作
```
0x65: ATOMIC.LOAD Rd, [Ra]   ; 原子加载
0x66: ATOMIC.STORE [Ra], Rb  ; 原子存储
0x67: ATOMIC.ADD Rd, [Ra], Rb ; 原子加
0x68: ATOMIC.SUB Rd, [Ra], Rb ; 原子减
0x69: ATOMIC.AND Rd, [Ra], Rb ; 原子与
0x6A: ATOMIC.OR  Rd, [Ra], Rb ; 原子或
0x6B: ATOMIC.XOR Rd, [Ra], Rb ; 原子异或
0x6C: ATOMIC.SWAP Rd, [Ra], Rb ; 原子交换
0x6D: ATOMIC.CAS Rd, [Ra], Rb, Rc ; 比较并交换
0x6E: MEMBAR type            ; 内存屏障
0x6F: PREFETCH [Ra], hint    ; 预取数据
```

### 2.4 控制流指令 (0x70-0x8F)

#### 无条件跳转
```
0x70: JMP    imm             ; 绝对跳转
0x71: JMPR   Ra              ; 寄存器跳转
0x72: JREL   imm             ; 相对跳转
```

#### 条件跳转
```
0x73: JEQ    Ra, Rb, imm     ; 等于跳转
0x74: JNE    Ra, Rb, imm     ; 不等于跳转
0x75: JGT    Ra, Rb, imm     ; 有符号大于跳转
0x76: JGE    Ra, Rb, imm     ; 有符号大于等于跳转
0x77: JLT    Ra, Rb, imm     ; 有符号小于跳转
0x78: JLE    Ra, Rb, imm     ; 有符号小于等于跳转
0x79: JGTU   Ra, Rb, imm     ; 无符号大于跳转
0x7A: JGEU   Ra, Rb, imm     ; 无符号大于等于跳转
0x7B: JLTU   Ra, Rb, imm     ; 无符号小于跳转
0x7C: JLEU   Ra, Rb, imm     ; 无符号小于等于跳转
```

#### 函数调用
```
0x7D: CALL   imm             ; 直接调用
0x7E: CALLR  Ra              ; 间接调用
0x7F: RET                    ; 返回
0x80: TAILCALL imm           ; 尾调用
0x81: TAILCALLR Ra           ; 间接尾调用
```

#### 标志位跳转
```
0x82: JZ     Ra, imm         ; 为零跳转
0x83: JNZ    Ra, imm         ; 非零跳转
0x84: JS     imm             ; 符号位为1跳转
0x85: JNS    imm             ; 符号位为0跳转
0x86: JO     imm             ; 溢出跳转
0x87: JNO    imm             ; 无溢出跳转
0x88: JC     imm             ; 进位跳转
0x89: JNC    imm             ; 无进位跳转
```

#### 条件移动
```
0x8A: CMOVE  Rd, Ra, Rb      ; 等于时移动
0x8B: CMOVNE Rd, Ra, Rb      ; 不等于时移动
0x8C: CMOVG  Rd, Ra, Rb      ; 大于时移动
0x8D: CMOVGE Rd, Ra, Rb      ; 大于等于时移动
0x8E: CMOVL  Rd, Ra, Rb      ; 小于时移动
0x8F: CMOVLE Rd, Ra, Rb      ; 小于等于时移动
```

### 2.5 对象操作指令 (0x90-0xAF)

#### 对象创建与销毁
```
0x90: NEW    Rd, type_id     ; 创建对象
0x91: NEWA   Rd, type_id, Ra ; 创建数组，大小为Ra
0x92: NEWM   Rd, method_id   ; 创建方法句柄
0x93: DEL    Ra              ; 删除对象
0x94: DELA   Ra              ; 删除数组
```

#### 字段访问
```
0x95: GETF   Rd, Ra, offset  ; 获取实例字段
0x96: PUTF   Ra, offset, Rb  ; 设置实例字段
0x97: GETS   Rd, class_id, offset ; 获取静态字段
0x98: PUTS   class_id, offset, Ra ; 设置静态字段
0x99: GETFA  Rd, Ra, Rb      ; 获取数组元素
0x9A: PUTFA  Ra, Rb, Rc      ; 设置数组元素
0x9B: ARRAYLEN Rd, Ra        ; 获取数组长度
```

#### 方法调用
```
0x9C: INVOKE Rd, Ra, method_id ; 虚方法调用
0x9D: INVOKESPECIAL Rd, Ra, method_id ; 特殊方法调用
0x9E: INVOKESTATIC Rd, class_id, method_id ; 静态方法调用
0x9F: INVOKEINTERFACE Rd, Ra, interface_id, method_id ; 接口方法调用
0xA0: INVOKEDYNAMIC Rd, call_site_id, args... ; 动态调用
```

#### 类型操作
```
0xA1: CAST   Rd, Ra, type_id ; 类型转换
0xA2: CHECKCAST Ra, type_id  ; 类型检查
0xA3: INSTANCEOF Rd, Ra, type_id ; 实例检查
0xA4: GETCLASS Rd, Ra        ; 获取类对象
0xA5: GETSUPER Ra, depth     ; 获取超类
0xA6: GETINTERFACES Rd, Ra   ; 获取接口列表
```

#### 反射操作
```
0xA7: GETFIELDID Rd, class_id, field_name ; 获取字段ID
0xA8: GETMETHODID Rd, class_id, method_sig ; 获取方法ID
0xA9: GETCONSTRUCTOR Rd, class_id, params ; 获取构造器
0xAA: GETANNOTATION Rd, target, anno_type ; 获取注解
0xAB: SETACCESSIBLE Ra, flag ; 设置可访问性
```

### 2.6 模块与包管理指令 (0xB0-0xCF)

#### 模块操作
```
0xB0: IMPORT Rd, module_id   ; 导入模块
0xB1: EXPORT symbol_id       ; 导出符号
0xB2: OPEN   module_id       ; 打开模块
0xB3: CLOSE  module_id       ; 关闭模块
0xB4: REQUIRES module_id, version ; 模块依赖
0xB5: PROVIDES service_id, impl_id ; 服务提供
0xB6: USES   service_id      ; 使用服务
```

#### 常量加载
```
0xB7: LDC    Rd, const_id    ; 加载常量
0xB8: LDS    Rd, str_id      ; 加载字符串
0xB9: LDCF   Rd, float_const ; 加载浮点常量
0xBA: LDCD   Rd, double_const ; 加载双精度常量
0xBB: LDCW   Rd, wide_const  ; 加载宽常量
0xBC: LDCMP  Rd, Ra, const_id ; 加载比较常量
```

#### 包操作
```
0xBD: PACKAGE package_id     ; 声明包
0xBE: IMPORT.PKG package_id  ; 导入包
0xBF: EXPORT.PKG package_id  ; 导出包
0xC0: OPENS  package_id, module_id ; 打开包
```

#### 服务加载
```
0xC1: LOADSERVICE Rd, service_id ; 加载服务
0xC2: FINDSERVICE Rd, service_type ; 查找服务
0xC3: INSTALLSERVICE Ra, service_impl ; 安装服务
0xC4: REMOVESERVICE service_id ; 移除服务
```

### 2.7 异常处理指令 (0xD0-0xDF)

#### 异常抛出
```
0xD0: THROW  Ra              ; 抛出异常
0xD1: THROWS Ra, type_id     ; 抛出特定类型异常
0xD2: RETHROW               ; 重新抛出当前异常
0xD3: THROWU Ra              ; 抛出未检查异常
```

#### 异常处理
```
0xD4: TRY    handler_addr    ; 开始try块
0xD5: CATCH  exception_type, handler_addr ; catch块
0xD6: FINALLY finally_addr   ; finally块
0xD7: ENDTRY                 ; 结束try块
0xD8: CATCHALL handler_addr  ; 捕获所有异常
```

#### 异常信息
```
0xD9: GETEXCEPTION Rd        ; 获取当前异常
0xDA: CLEAREXCEPTION        ; 清除异常
0xDB: SETSTACKTRACE Ra      ; 设置堆栈跟踪
0xDC: GETSTACKTRACE Rd      ; 获取堆栈跟踪
0xDD: GETCAUSE Rd           ; 获取异常原因
0xDE: GETMESSAGE Rd         ; 获取异常消息
0xDF: FILLINSTACKTRACE      ; 填充堆栈跟踪
```

### 2.8 同步指令 (0xE0-0xEF)

#### 锁操作
```
0xE0: MONITORENTER Ra       ; 进入监视器
0xE1: MONITOREXIT Ra        ; 退出监视器
0xE2: TRYMONITORENTER Rd, Ra ; 尝试进入监视器
0xE3: LOCK   Ra             ; 获取锁
0xE4: UNLOCK Ra             ; 释放锁
0xE5: TRYLOCK Rd, Ra        ; 尝试获取锁
```

#### 同步方法
```
0xE6: SYNCMETHOD method_id  ; 同步方法
0xE7: SYNCDECLARE flags     ; 声明同步属性
0xE8: SYNCBLOCK Ra          ; 同步块
0xE9: ENDSYNC              ; 结束同步
```

#### 条件变量
```
0xEA: WAIT   Ra             ; 等待条件
0xEB: WAITN  Ra, timeout    ; 等待条件（超时）
0xEC: NOTIFY Ra             ; 通知一个等待者
0xED: NOTIFYALL Ra          ; 通知所有等待者
0xEE: AWAITSIGNAL Rd, Ra    ; 等待信号
0xEF: SIGNAL Ra             ; 发送信号
```

### 2.9 系统与调试指令 (0xF0-0xFF)

#### 系统调用
```
0xF0: SYSCALL call_id, Ra, Rb ; 系统调用
0xF1: BREAK                  ; 断点
0xF2: TRAP   trap_id         ; 陷阱
0xF3: DEBUG  debug_cmd       ; 调试命令
0xF4: PROFILE profile_cmd    ; 性能分析
0xF5: TRACE  trace_cmd       ; 跟踪命令
```

#### 虚拟机控制
```
0xF6: HALT   exit_code       ; 停止虚拟机
0xF7: GC     gc_type         ; 垃圾回收
0xF8: GCINFO Rd              ; 获取GC信息
0xF9: HEAPINFO Rd            ; 获取堆信息
0xFA: THREADINFO Rd          ; 获取线程信息
0xFB: STACKINFO Rd           ; 获取栈信息
```

#### 资源管理
```
0xFC: ALLOC  Rd, size        ; 分配内存
0xFD: FREE   Ra              ; 释放内存
0xFE: RESIZE Ra, new_size    ; 调整内存大小
0xFF: MEMINFO Rd, addr       ; 获取内存信息
```

---

## 3. 特殊寄存器指令（专用指令）

### 3.1 条件码操作
```
CC.SET   flag, value         ; 设置条件码
CC.GET   Rd, flag            ; 获取条件码
CC.CLEAR flag                ; 清除条件码
CC.TEST  flag                ; 测试条件码
CC.SAVE  Rd                  ; 保存条件码
CC.RESTORE Ra                ; 恢复条件码
```

### 3.2 浮点状态寄存器
```
FPSR.SET   Rd, value         ; 设置浮点状态
FPSR.GET   Rd                ; 获取浮点状态
FPSR.CLEAR exceptions        ; 清除浮点异常
FPSR.TEST  exception         ; 测试浮点异常
```

### 3.3 性能计数器
```
PMU.READ Rd, counter_id      ; 读取性能计数器
PMU.WRITE counter_id, value  ; 写入性能计数器
PMU.START counter_id         ; 启动计数器
PMU.STOP  counter_id         ; 停止计数器
PMU.RESET counter_id         ; 重置计数器
```

---

## 4. 向量扩展指令集 (KRIC-V)

### 4.1 向量加载/存储
```
VLOAD   Vd, [Ra+imm], stride ; 向量加载
VSTORE  [Ra+imm], Vb, stride ; 向量存储
VLOADU  Vd, [Ra+imm]         ; 不对齐向量加载
VSTOREU [Ra+imm], Vb         ; 不对齐向量存储
VGATHER Vd, [Ra], Vi         ; 向量收集
VSCATTER [Ra], Vb, Vi        ; 向量散播
```

### 4.2 向量算术
```
VADD    Vd, Va, Vb           ; 向量加法
VSUB    Vd, Va, Vb           ; 向量减法
VMUL    Vd, Va, Vb           ; 向量乘法
VDIV    Vd, Va, Vb           ; 向量除法
VFMA    Vd, Va, Vb, Vc       ; 向量融合乘加
VDOT    Vd, Va, Vb           ; 向量点积
```

### 4.3 向量归约
```
VREDUCE.SUM Rd, Va           ; 向量求和归约
VREDUCE.MAX Rd, Va           ; 向量最大值归约
VREDUCE.MIN Rd, Va           ; 向量最小值归约
VREDUCE.AND Rd, Va           ; 向量与归约
VREDUCE.OR  Rd, Va           ; 向量或归约
VREDUCE.XOR Rd, Va           ; 向量异或归约
```

### 4.4 向量掩码操作
```
VMASK.LOAD  Vd, [Ra], mask   ; 掩码加载
VMASK.STORE [Ra], Vb, mask   ; 掩码存储
VMASK.MOV   Vd, Va, mask     ; 掩码移动
VMASK.BLEND Vd, Va, Vb, mask ; 掩码混合
```

---

## 5. 特殊优化指令

### 5.1 分支预测
```
PREDICT.TAKEN    addr        ; 预测分支跳转
PREDICT.NOT_TAKEN addr       ; 预测分支不跳转
BRANCH.HINT      addr, prob  ; 分支概率提示
LOOP.HINT        count       ; 循环提示
```

### 5.2 内存优化
```
PREFETCH.L1 [Ra]             ; L1缓存预取
PREFETCH.L2 [Ra]             ; L2缓存预取
PREFETCH.L3 [Ra]             ; L3缓存预取
PREFETCH.NTA [Ra]            ; 非临时预取
STREAMING.STORE [Ra], Rb     ; 流式存储
NON.TEMPORAL.LOAD Rd, [Ra]   ; 非临时加载
```

### 5.3 执行优化
```
NOOP                          ; 空操作
HINT    hint_code            ; 执行提示
BARRIER barrier_type         ; 执行屏障
FENCE   fence_type           ; 内存栅栏
SPECULATE speculation_type   ; 推测执行
```

---

## 6. 编码示例

### 6.1 ADD指令编码
```
ADD R10, R20, R30
二进制: 00000000 00001010 00010100 00011110
十六进制: 0x000A141E

操作码: 0x00 (ADD)
Rd: 0x0A (R10)
Ra: 0x14 (R20)
Rb: 0x1E (R30)
```

### 6.2 LOAD指令编码
```
LOAD R5, [R8+100]
二进制: 01010000 00000101 00001000 01100100
十六进制: 0x50050864

操作码: 0x50 (LOAD)
Rd: 0x05 (R5)
Ra: 0x08 (R8)
imm8: 0x64 (100)
```

### 6.3 JMP指令编码
```
JMP 0x1000
二进制: 01110000 00000001 00000000 00000000
十六进制: 0x70010000

操作码: 0x70 (JMP)
imm24: 0x001000 (扩展为24位)
```

---

## 7. 伪指令（汇编宏）

### 7.1 数据传输
```
MOV   Rd, Ra          ; Rd = Ra
MOVI  Rd, imm         ; 加载立即数
MOVA  Rd, addr        ; 加载地址
SWAP  Ra, Rb          ; 交换寄存器值
```

### 7.2 流程控制
```
NOP                   ; 空操作
LOOP  label, count    ; 循环
WHILE  cond, label    ; 当循环
REPEAT label, count   ; 重复循环
```

### 7.3 数据转换
```
ZEXT  Rd, Ra          ; 零扩展
SEXT  Rd, Ra          ; 符号扩展
TRUNC Rd, Ra          ; 截断
ROUND Rd, Ra          ; 舍入
```

---

## 8. 指令执行周期

| 指令类别 | 基本周期 | 流水线阶段 | 旁路支持 |
|---------|---------|-----------|---------|
| 算术指令 | 1       | EX        | 是      |
| 逻辑指令 | 1       | EX        | 是      |
| 移位指令 | 1       | EX        | 是      |
| 加载指令 | 3-10    | MEM       | 部分    |
| 存储指令 | 1       | MEM       | 否      |
| 跳转指令 | 1       | ID        | 预测    |
| 调用指令 | 2       | ID+EX     | 否      |
| 浮点指令 | 3-15    | FPU       | 是      |
| 向量指令 | 2-8     | VFU       | 是      |
| 系统指令 | 10-100  | SYS       | 否      |

---

## 9. 指令编码表（操作码映射）

| 操作码范围 | 指令类别       | 指令数量 |
|-----------|---------------|---------|
| 0x00-0x1F | 整数运算       | 32      |
| 0x20-0x2F | 移位运算       | 16      |
| 0x30-0x4F | 浮点运算       | 32      |
| 0x50-0x6F | 内存访问       | 32      |
| 0x70-0x8F | 控制流         | 32      |
| 0x90-0xAF | 对象操作       | 32      |
| 0xB0-0xCF | 模块管理       | 32      |
| 0xD0-0xDF | 异常处理       | 16      |
| 0xE0-0xEF | 同步操作       | 16      |
| 0xF0-0xFF | 系统指令       | 16      |

---

**Nexogic Korelin Bytecode v2.0 - 指令集规范**
**总指令数: 256个基础指令 + 扩展指令**